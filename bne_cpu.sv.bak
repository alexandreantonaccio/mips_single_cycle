module bne_cpu (
    input  logic        clk, reset,
    output logic [31:0] PC,
    input  logic [31:0] Instr,
    output logic        MemWrite,
    output logic [31:0] ALUResult, WriteData,
    input  logic [31:0] ReadData
);

    // Sinais internos
    logic [1:0]  RegDst, MemtoReg, PCSrc;
    logic        RegWrite, ALUSrc, Branch, Jump, JumpReg;
    logic [1:0]  ALUOp;
    logic [31:0] PCNext, PCPlus4, PCBranch;
    logic [31:0] SignImm, ShiftedImm;
    logic [31:0] SrcA, SrcB, RD2;
    logic [4:0]  WriteReg;
    logic [31:0] Result;
    logic        Zero;
    logic [3:0]  ALUControl;

    // Registrador PC
    always_ff @(posedge clk, posedge reset) begin
        if (reset) PC <= 0;
        else       PC <= PCNext;
    end

    // Lógica do próximo PC
    assign PCPlus4 = PC + 4;
    assign ShiftedImm = SignImm << 2;
    assign PCBranch = PC + ShiftedImm;

    assign PCSrc = (JumpReg) ? 2'b11 : 
                   (Jump)    ? 2'b10 : 
                   (Branch & Zero) ? 2'b01 : 2'b00;

    always_comb begin
        case (PCSrc)
            2'b00: PCNext = PCPlus4;
            2'b01: PCNext = PCBranch;
            2'b10: PCNext = {PCPlus4[31:28], Instr[25:0], 2'b00};
            2'b11: PCNext = SrcA;
            default: PCNext = PCPlus4;
        endcase
    end

    // Banco de registradores
    register_file rf (
        .clk(clk),
        .we3(RegWrite),
        .ra1(Instr[25:21]),
        .ra2(Instr[20:16]),
        .wa3(WriteReg),
        .wd3(Result),
        .rd1(SrcA),
        .rd2(RD2)
    );

    assign WriteData = RD2;

    // Mux para registrador de destino
    assign WriteReg = (RegDst == 2'b00) ? Instr[20:16] : 
                     (RegDst == 2'b01) ? Instr[15:11] : 
                     5'b11111; // $ra

    // Mux para dado de escrita
    assign Result = (MemtoReg == 2'b00) ? ALUResult : 
                   (MemtoReg == 2'b01) ? ReadData : 
                   PCPlus4; // jal

    // Extensão de sinal
    sign_extend se (
        .instr(Instr[15:0]),
        .imm(SignImm)
    );

    // Mux para SrcB da ALU
    assign SrcB = (ALUSrc) ? SignImm : RD2;

    // ALU
    alu alu (
        .a(SrcA),
        .b(SrcB),
        .alu_control(ALUControl),
        .result(ALUResult),
        .zero(Zero)
    );

    // Unidade de controle
    control_unit control (
        .op(Instr[31:26]),
        .funct(Instr[5:0]),
        .RegDst(RegDst),
        .Jump(Jump),
        .JumpReg(JumpReg),
        .Branch(Branch),
        .MemWrite(MemWrite),
        .MemtoReg(MemtoReg),
        .ALUSrc(ALUSrc),
        .RegWrite(RegWrite),
        .ALUOp(ALUOp)
    );

    // Controle da ALU
    alu_control alu_ctrl (
        .funct(Instr[5:0]),
        .ALUOp(ALUOp),
        .alu_control(ALUControl)
    );

endmodule

module register_file (
    input  logic        clk, we3,
    input  logic [4:0]  ra1, ra2, wa3,
    input  logic [31:0] wd3,
    output logic [31:0] rd1, rd2,
	 output logic [31:0] rf [0:31] 
);

    always_ff @(posedge clk) begin
        if (we3) rf[wa3] <= wd3;
    end

    assign rd1 = (ra1 != 0) ? rf[ra1] : 0;
    assign rd2 = (ra2 != 0) ? rf[ra2] : 0;

endmodule

module sign_extend (
    input  logic [15:0] instr,
    output logic [31:0] imm
);

    assign imm = {{16{instr[15]}}, instr};

endmodule

module control_unit (
    input  logic [5:0] op, funct,
    output logic [1:0] RegDst,
    output logic       Jump, JumpReg,
    output logic       Branch, MemWrite,
    output logic [1:0] MemtoReg,
    output logic       ALUSrc, RegWrite,
    output logic [1:0] ALUOp
);

    always_comb begin
        // Valores padrão
        RegDst   = 2'b00;
        Jump     = 0;
        JumpReg  = 0;
        Branch   = 0;
        MemWrite = 0;
        MemtoReg = 2'b00;
        ALUSrc   = 0;
        RegWrite = 0;
        ALUOp    = 2'b00;

        case (op)
            6'b000000: begin // R-type
                RegDst   = 2'b01;
                RegWrite = 1;
                ALUOp    = 2'b10;
                if (funct == 6'b001000) begin // jr
                    JumpReg = 1;
                    RegWrite = 0;
                end
            end
            6'b100011: begin // lw
                ALUSrc   = 1;
                MemtoReg = 2'b01;
                RegWrite = 1;
            end
            6'b101011: begin // sw
                ALUSrc   = 1;
                MemWrite = 1;
            end
            6'b000100: begin // beq
                Branch   = 1;
                ALUOp    = 2'b01;
            end
            6'b001000: begin // addi
                ALUSrc   = 1;
                RegWrite = 1;
            end
            6'b000010: begin // j
                Jump     = 1;
            end
            6'b000011: begin // jal
                Jump     = 1;
                RegWrite = 1;
                RegDst   = 2'b10;
                MemtoReg = 2'b10;
            end
            6'b001010: begin // slti (corrigido)
                RegDst = 2'b00;   // Escreve em rt
                ALUSrc = 1;        // Usa imediato
                RegWrite = 1;       // Habilita escrita
                ALUOp = 2'b11;      // Operação SLT
                Jump = 0;
                Branch = 0;
                MemWrite = 0;
                MemtoReg = 2'b00;
            end
            default: ; 
        endcase
    end

endmodule

module alu_control (
    input  logic [5:0] funct,
    input  logic [1:0] ALUOp,
    output logic [3:0] alu_control
);

    always_comb
        case (ALUOp)
            2'b00: alu_control = 4'b0010; // add
            2'b01: alu_control = 4'b0110; // sub
            2'b10: case (funct)
                        6'b100000: alu_control = 4'b0010; // add
                        6'b100010: alu_control = 4'b0110; // sub
                        6'b100100: alu_control = 4'b0000; // and
                        6'b100101: alu_control = 4'b0001; // or
                        6'b101010: alu_control = 4'b0111; // slt
                        6'b000000: alu_control = 4'b0011; // sll
                        default:   alu_control = 4'b0010;
                    endcase
            2'b11: alu_control = 4'b0111; // slt
            default: alu_control = 4'b0010;
        endcase

endmodule

module alu (
    input  logic [31:0] a, b,
    input  logic [3:0]  alu_control,
    output logic [31:0] result,
    output logic        zero
);

    always_comb begin
        case (alu_control)
            4'b0000: result = a & b;
            4'b0001: result = a | b;
            4'b0010: result = a + b;
            4'b0110: result = a - b;
            4'b0111: begin // slt corrigido (signed comparison)
                result = ($signed(a) < $signed(b)) ? 32'd1 : 32'd0;
            end
            4'b0011: result = b << a[4:0];
            default: result = a + b;
        endcase
        zero = (result == 0);
    end

endmodule