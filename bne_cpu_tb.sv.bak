////////////////////////////////////////////////////////////////////////////////
// Testbench for extended operations
////////////////////////////////////////////////////////////////////////////////
module bne_cpu_tb;
    logic clk = 0, reset;
    logic [31:0] pc;
    logic [31:0] instr;
    logic memwrite;
    logic [31:0] dataadr, writedata;
    logic [31:0] readdata = 0;

    // Instantiate CPU
    mips_extended cpu(
        .clk(clk), .reset(reset), .pc(pc), .instr(instr),
        .memwrite(memwrite), .dataadr(dataadr), .writedata(writedata),
        .readdata(readdata)
    );

    // Clock generator
    always #5 clk = ~clk;

    initial begin
        reset = 1; #10;
        reset = 0;

        // Test ADD: opcode=0, funct=100000, rs=1, rt=2, rd=3
        instr = 32'b000000_00001_00010_00011_00000_100000;
        #10;
        $display("ADD result=%0d (expect src1+src2)", cpu.aluout);

        // Test SLT: funct=101010
        instr = 32'b000000_00001_00010_00100_00000_101010;
        #10;
        $display("SLT result=%0d (1 if src1<src2)", cpu.aluout);

        // Test ADDI: opcode=001000
        instr = 32'b001000_00001_00011_00000_00000_000001;
        #10;
        $display("ADDI result=%0d (src1+imm)", cpu.aluout);

        // Test BEQ: opcode=000100, offset=1
        instr = 32'b000100_00001_00001_00000_00000_000001;
        #10;
        $display("BEQ PC next=%0d (branch taken)", cpu.pc);

        // Test J: opcode=000010, target=4
        instr = 32'b000010_000000000000000000000100;
        #10;
        $display("J PC next=%0d (jump to 16)", cpu.pc);

        // Test JAL: opcode=000011
        instr = 32'b000011_000000000000000000000101;
        #10;
        $display("JAL PC next=%0d, $ra=%0d", cpu.pc, cpu.rf.rf[31]);

        // Test JR: R-type funct=001000, rs=4
        instr = 32'b000000_00100_00000_00000_00000_001000;
        cpu.rf.rf[4] = 32'h00000020; // set reg4
        #10;
        $display("JR PC next=%0d (expect 0x20)", cpu.pc);

        $finish;
    end
endmodule